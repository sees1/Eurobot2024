#!/usr/bin/env python
PACKAGE = "neo_local_planner"

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

gen.add("acc_lim_x",               double_t,    0, "The x acceleration limit of the robot in meters/sec^2",                                   0.2, 0, 10)
gen.add("acc_lim_y",               double_t,    0, "The y acceleration limit of the robot in meters/sec^2",                                   0.3, 0, 10)
gen.add("acc_lim_theta",           double_t,    0, "The rotational acceleration limit of the robot in radians/sec^2",                         0.15, 0, 10)
gen.add("acc_limit_trans",         double_t,    0, "EMPTY",                                                                                   0.2, 0, 10)
gen.add("min_vel_x",               double_t,    0, "The minimum x velocity for the robot in m/s, negative for backwards motion.",            -1.5, -10, 10)
gen.add("max_vel_x",               double_t,    0, "The maximum x velocity for the robot in m/s.",                                            1.5, -10, 10)
gen.add("min_vel_y",               double_t,    0, "The minimum y velocity for the robot in m/s, negative for backwards motion.",            -0.6, -10, 10)
gen.add("max_vel_y",               double_t,    0, "The maximum y velocity for the robot in m/s.",                                            0.6, -10, 10)
gen.add("min_rot_vel",             double_t,    0, "The absolute value of the minimum rotational velocity for the robot in rad/s",            0.05, 0, 10)
gen.add("max_rot_vel",             double_t,    0, "The absolute value of the maximum rotational velocity for the robot in rad/s",            0.25, 0, 10)
gen.add("min_trans_vel",           double_t,    0, "The absolute value of the minimum translational velocity for the robot in m/s",           0.01, -10, 10)
gen.add("max_trans_vel",           double_t,    0, "The absolute value of the maximum translational velocity for the robot in m/s",           0.6, -10, 10)
gen.add("rot_stopped_vel",         double_t,    0, "EMPTY",                                                                                   0.0025, -10, 10)
gen.add("trans_stopped_vel",       double_t,    0, "EMPTY",                                                                                   0.005, -10, 10)
gen.add("yaw_goal_tolerance",      double_t,    0, "The tolerance in radians for the controller in yaw/rotation when achieving its goal",     0.1, 0, 10)
gen.add("xy_goal_tolerance",       double_t,    0, "The tolerance in meters for the controller in the x & y distance when achieving a goal",  0.1, 0, 10)
gen.add("differential_drive",      bool_t,      0, "If robot has differential drive, holonomic otherwise",                                    False)
gen.add("constrain_final",         bool_t,      0, "EMPTY",                                                                                   False)
gen.add("goal_tune_time",          double_t,    0, "How long to fine tune for goal position after reaching tolerance limits [s]",             0, 0, 10)
gen.add("lookahead_time",          double_t,    0, "How far to predict control pose into the future based on latest odometry [s]",            0.2,  0, 10)
gen.add("lookahead_dist",          double_t,    0, "How far to look ahead when computing path orientation [m]",                               0.05, 0, 10)
gen.add("start_yaw_error",         double_t,    0, "Threshold yaw error below which we consider to start moving [rad]",                       0.1, 0, 10)
gen.add("pos_x_gain",              double_t,    0, "Gain when adjusting final x position for goal [1/s]",                                     0.4,  0, 10)
gen.add("pos_y_gain",              double_t,    0, "Gain when adjusting final y position for goal [1/s]",                                     0.48, 0, 10)
gen.add("pos_y_yaw_gain",          double_t,    0, "Gain for lane keeping based on y error (differential only) [rad/s^2]",                    1.0, 0, 10)
gen.add("yaw_gain",                double_t,    0, "Gain for lane keeping based on yaw error (differential only) [1/s]",                      2.0, 0, 10)
gen.add("static_yaw_gain",         double_t,    0, "Gain for adjusting yaw when not translating, or in case of holonomic drive [1/s]",        0.1, 0, 10)
gen.add("cost_x_gain",             double_t,    0, "EMPTY",                                                                                   0.2, 0, 10)
gen.add("cost_y_gain",             double_t,    0, "EMPTY",                                                                                   0.2, 0, 10)
gen.add("cost_y_yaw_gain",         double_t,    0, "Gain for y cost avoidance (differential only)",                                           3.0, 0, 10)
gen.add("cost_y_lookahead_dist",   double_t,    0, "How far ahead to compute y cost gradient (constant offset) [m]",                          0.3, 0, 10)
gen.add("cost_y_lookahead_time",   double_t,    0, "How far ahead to compute y cost gradient (dynamic offset) [s]",                           0.2, 0, 10)
gen.add("cost_yaw_gain",           double_t,    0, "Gain for yaw cost avoidance",                                                             0.02, 0, 10)
gen.add("low_pass_gain",           double_t,    0, "Gain for final control low pass filter",                                                  0.3, 0, 10)
gen.add("max_cost",                double_t,    0, "Max cost to allow, above we slow down to min_trans_vel or even stop",                     0.95, 0, 10)
gen.add("max_curve_vel",           double_t,    0, "Max velocity based on curvature [rad/s]",                                                 0.8, 0, 10)
gen.add("max_goal_dist",           double_t,    0, "Max distance to goal when looking for it [m]",                                            0.1, 0, 10)
gen.add("max_backup_dist",         double_t,    0, "Max distance allowable for backing up (zero = unlimited) [m]",                            0.0, 0, 10)
gen.add("min_stop_dist",           double_t,    0, "Minimal distance for stopping [m]",                                                       0.3, 0, 10)
gen.add("emergency_acc_lim_x",     double_t,    0, "EMPTY",                                                                                   0.8, 0, 10)
gen.add("enable_software_stop",    bool_t,      0, "EMPTY",                                                                                   True)
gen.add("allow_reversing",         bool_t,      0, "robot with safety sensors in the rear can be set to reverse",                             False)

exit(gen.generate(PACKAGE, "neo_local_planner", "NeoLocalPlanner"))