cam_base_topic: usb_cam/image_raw
image_is_rectified: false
output_frame: ''

marker_dict: 4X4_50

publish_tf: true
marker_size: 0.1
image_queue_size: 1

# Dynamically reconfigurable Detector parameters
# https://docs.opencv.org/4.2.0/d5/dae/tutorial_aruco_detection.html

# THRESHOLDING PARAMETERS

# минимальная сетка
adaptiveThreshWinSizeMin: 3
# максимальная сетка
adaptiveThreshWinSizeMax: 23
# шаг сетки (чем меньше шаг, тем больше процедур вычисления положения маркера происходит)
adaptiveThreshWinSizeStep: 4
# дефолтное значение ошибки (в каких то там операциях, 7 - дефолт, неплохо оптимизировано)
adaptiveThreshConstant: 7

# CONTOUR FILTERING PARAMETERS

# минимальное значение размера маркера на изображении (в пикселях) (те относится к разрешению камеры)
# значение = 0 начинает учитывать все прямоугольные контура - плохо для производительности
minMarkerPerimeterRate: 0.03
# максимальное значение размера маркера на изображении (в пикселях)
# значение >= 4 начинает учитывать все прямоугольный контура - плохо для производительности
maxMarkerPerimeterRate: 4.0 # ОБЯЗАТЕЛЬНО ПОМЕНЯТЬ!
# значение ошибки - относительно размера маркера (Perimeter * approxAccuracyRate = кол-во пикселей
# на которое может ошибиться апроксимация метки в полигон)
polygonalApproxAccuracyRate: 0.03
# значение минимальной границы метки, относительно периметра метки (Perimeter * minCornerDistanceRate = minCorner)
minCornerDistanceRate: 0.05
# значение минимального расстояния между границами любых двух различных меток. Если параметр слишком мал и метки 
# слишком близки, то метка с меньшим Perimeter будет откинута
minMarkerDistanceRate: 0.05
# минимальное расстояние от любого угла любой метки до границы изображения. Для точной локализации, не рекомендуется
# распологать метки в близи границы изображения
minDistanceToBorder: 3 # default = 3, in pixels
# размер бита при разбиении на сетку, должен совпадать с размером бита, при создании метки
# те с размером использующемся в generateImageMarker() функции

#BITS EXTRACTION PARAMETERS

markerBorderBits: 1
minOtsuStdDev: 5.0 #default = 5.0
# значительно увеличивает точность вычисления на этапе битовой сетки до некоторого значения
# будем посмотреть - поменять 
perspectiveRemovePixelPerCell: 4
# снижение размера границы одной ячейки (те если ячейка была 40*40 бит то после снижения станет
# 40*0.13 + 40*0.13 = 10.4 те ячейка будет учитывать только 29.6 бит внутри себя для определения цвета
# ячейки ). Параметр нужен, когда перспективая у маркера съезжает и черные пиксели заходят на белые и наооборт
# и если учитывать все 40*40 бит, то выходит что у одной ячейки может быть два цвета (например белый в середке
# и черный по краям от другой съехавшей ячейки)
perspectiveRemoveIgnoredMarginPerCell: 0.13
# количество белых ячеек относительно общего числа ячеек.
maxErroneousBitsInBorderRate: 0.35 # default = 0.35

#MARKER IDENTIFICATION PARAMETERS

# Возможности для исправления ошибок, зависит от количества пикселей разрешенных к исправлению 
# в ячейке (те от Dictionary.maxCorrectionBits). 1 - использовать все корректирующие биты
# 0.6 использовать только 60 процентов возможностей исправления (обрезают с целью уменьшения)
# ложно-положительных результатов
errorCorrectionRate: 0.6
cornerRefinementMethod: 3 # 0 - None, 1 - Subpix, 2 - Contour, 3 - Apriltag
# более высокое значение ( не больше 0.6) - более точное вычисление границ метки
cornerRefinementWinSize: 0.3 #default = 0.3
# количество итераций процесса определения границ метки, чем больше - тем лучше, но влияет на перформанс
cornerRefinementMaxIterations: 30 #default = 30
# ошибка ниже которой прекращается вычисление границы метки. По сути threshold для процесса определения
# границ метки.
cornerRefinementMinAccuracy: 0.1
